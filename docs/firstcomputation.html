
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A First Scientific Computation &#8212; A Short Introduction to Parallel Computing</title>
    
  <link rel="stylesheet" href="_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.e7340bb3dbd8dde6db86f25597f54a1b.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Message Passing Interface" href="intro.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  
  <h1 class="site-logo" id="site-title">A Short Introduction to Parallel Computing</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="README.html">
   A Short Introduction to Parallel Computing
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="parallel-computing.html">
   Scientific and parallel computing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="parallel-computing.html#parallel-algorithms">
   Parallel Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Message Passing Interface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html#point-to-point-communication">
   Point-to-point communication
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   A First Scientific Computation
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/firstcomputation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/Cirdans-Home/intrompi"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/Cirdans-Home/intrompi/issues/new?title=Issue%20on%20page%20%2Ffirstcomputation.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/Cirdans-Home/intrompi/edit/main/firstcomputation.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/Cirdans-Home/intrompi/main?urlpath=lab/tree/firstcomputation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#full-implementation">
   Full implementation
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="a-first-scientific-computation">
<h1>A First Scientific Computation<a class="headerlink" href="#a-first-scientific-computation" title="Permalink to this headline">¶</a></h1>
<p>The 1st derivative of a function with finite differences Given a
function <span class="math notranslate nohighlight">\(f(x) : [a,b] \rightarrow \mathbb{R}\)</span> we want to approximate
<span class="math notranslate nohighlight">\(f'(x)\)</span> on a (uniform) grid on the <span class="math notranslate nohighlight">\([a,b]\)</span> interval by using a finite
difference scheme in parallel.</p>
<ul>
<li><p>Given an integer <span class="math notranslate nohighlight">\(n \in \mathbb{N}\)</span> we can subdivide the interval
<span class="math notranslate nohighlight">\([a,b]\)</span> into intervals of length <span class="math notranslate nohighlight">\(\Delta x = \frac{(b-a)}{n-1}\)</span>
with grid points
<span class="math notranslate nohighlight">\(\{x_j\}_{j=0}^{n} = \{x_j = a + j \Delta x\}_{j=0}^{n-1}\)</span>:</p>
<p>,</p>
</li>
<li><p>and consider the values
<span class="math notranslate nohighlight">\(\{f_j\}_{j=0}^{n-1} = \{f(x_j)\}_{j=0}^{n-1}\)</span></p></li>
<li><p>We can approximate the values of <span class="math notranslate nohighlight">\(f'(x_j)\)</span>, for <span class="math notranslate nohighlight">\(j=1,\ldots,n-2\)</span>, by
using only the values of <span class="math notranslate nohighlight">\(f\)</span> at the knots <span class="math notranslate nohighlight">\(\{f_j\}_{j=0}^{n-1}\)</span></p></li>
</ul>
<p>The 1st derivative of a function with finite differences</p>
<ul class="simple">
<li><p>The first derivative of <span class="math notranslate nohighlight">\(f\)</span> at <span class="math notranslate nohighlight">\(x = x_j\)</span> can be expressed by using
knots for <span class="math notranslate nohighlight">\(j' &gt; j\)</span>
<img alt="figure1" src="_images/figure1.png" /></p></li>
<li><p>or equivalently by using knots for <span class="math notranslate nohighlight">\(j' &lt; j\)</span>
<img alt="figure2" src="_images/figure2.png" /></p></li>
<li><p>at last we can consider the arithmetic mean of previous two:
<img alt="figure3" src="_images/figure3.png" /></p></li>
</ul>
<p>Writing the sequential algorithm The sequential algorithms needs to
break the approximation process into three parts</p>
<ol class="simple">
<li><p>evaluate the derivative <span class="math notranslate nohighlight">\(f'(x_i)\)</span> for <span class="math notranslate nohighlight">\(i=1,\ldots,n-2\)</span>,</p></li>
<li><p>evaluate the derivative at the left–hand side <span class="math notranslate nohighlight">\(f'(x_0)\)</span>,</p></li>
<li><p>evaluate the derivative at the right–hand side <span class="math notranslate nohighlight">\(f'(x_{n-1})\)</span>.</p></li>
</ol>
<p>To have the same <em>order of approximation</em> at each point of the grid we
need to use a one–sided formula for the steps 2 and
3, specifically
$<span class="math notranslate nohighlight">\(f'(x_0) \approx \frac{-3 f_0 + 4 f_1 - f_2}{2 \Delta x}, \quad f'(x_{n-1}) \approx \frac{3f_{n-1} -4 f_{n-2} + f_{n-3}}{2 \Delta x}\)</span>$</p>
<p>Writing the sequential algorithm Then the sequential algorithm can be
written as</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">firstderiv1D_vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">){</span>
<span class="kt">double</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="mi">-1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
 <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">-3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-2</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-3</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
 <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function takes as input</p>
<ul class="simple">
<li><p>the number of grid points is <span class="math notranslate nohighlight">\(n\)</span>,</p></li>
<li><p>the amplitude of such intervals <span class="math notranslate nohighlight">\(\Delta x\)</span>,</p></li>
<li><p>the array containing the evaluation of <span class="math notranslate nohighlight">\(f\)</span> (intent: input),</p></li>
<li><p>the array that will contain the value of the derivative (intent:
output)</p></li>
</ul>
<p>Writing the parallel algorithm To implement the sequential differencing
functions in parallel with MPI, we have to perform several steps</p>
<ol class="simple">
<li><p>partition our domain <span class="math notranslate nohighlight">\([a,b]\)</span> among the processors,</p></li>
<li><p>each processor then computes the finite differences for all the
points contained on that processor</p></li>
</ol>
<p>To actually perform the second step, we need to observe that the
end-points on each subdomain needs information that is not contained on
the processor, but that resides on a different one, we need to
communicate boundary data!</p>
<p>Red dots are <em>halo</em> data, the one we need to communicate, while gray
dots are data owned by the process.</p>
<p>Writing the parallel algorithm The prototype of the function we want to
write can be, in this case,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">firstderiv1Dp_vec</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
  <span class="kt">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mynode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalnodes</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code> is the number of points per process,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">dx</span></code> the amplitude of each interval,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">*f,</span> <span class="pre">double</span> <span class="pre">*fx</span></code> the local portions with the values of
<span class="math notranslate nohighlight">\(f(x)\)</span> (input) and <span class="math notranslate nohighlight">\(f'(x)\)</span> (output),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mynode</span></code> the rank of the current process,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">totalnodes</span></code> the size of the communicator</p></li>
</ul>
<p>We declare then the variables</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">mpitemp</span><span class="p">;</span>
<span class="n">MPI_Status</span> <span class="n">status</span><span class="p">;</span>
</pre></div>
</div>
<p>Writing the parallel algorithm Then we can treat the case in which we
are at the beginning or at the end of the global interval</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
 <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">-3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="p">(</span><span class="n">totalnodes</span><span class="mi">-1</span><span class="p">)){</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-2</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-3</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>this approximate the derivative at the first and last point of the
global interval.</p>
<p>Then, we can compute the inner part (the gray points) of the local
interval by doing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Writing the parallel algorithm The other case we need to treat is again
the particular case in which we are in the first, or in the last
interval. In both cases we have only one communication to perform</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
 <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">];</span>
 <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
 <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpitemp</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="p">(</span><span class="n">totalnodes</span><span class="mi">-1</span><span class="p">)){</span>
 <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> 
   <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">mpitemp</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
 <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
 <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Writing the parallel algorithm Finally, the only remaining case is the
one in which we need to communicate both the extremes of the interval</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">else</span><span class="p">{</span>
 <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> 
   <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">mpitemp</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
 <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
 <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
 <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">];</span>
 <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
 <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> 
   <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpitemp</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="mi">-2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And the routine is complete!</p>
<p>Writing the parallel algorithm A simple (and not very useful) principal
program for this routine can be written by first initializing the
parallel environment, and discovering who we are.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MPI_Init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span> <span class="p">);</span>
<span class="n">MPI_Comm_rank</span><span class="p">(</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mynode</span> <span class="p">);</span>
<span class="n">MPI_Comm_size</span><span class="p">(</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">totalnodes</span> <span class="p">);</span>
</pre></div>
</div>
<p>Then we build the local values of the <span class="math notranslate nohighlight">\(f\)</span> function</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">globala</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">globalb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">globala</span> <span class="o">+</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">mynode</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">globalb</span> <span class="o">-</span> <span class="n">globala</span><span class="p">)</span>
    <span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">totalnodes</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">globala</span> <span class="o">+</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">mynode</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">globalb</span> <span class="o">-</span> <span class="n">globala</span><span class="p">)</span>
    <span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">totalnodes</span><span class="p">);</span>
<span class="n">f</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
 <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally we invoke our parallel computation</p>
<p>Writing the parallel algorithm To check if what we have done makes sens
we evaluate the error in the <span class="math notranslate nohighlight">\(\|\cdot\|_2\)</span> norm on the grid, i.e.,
<span class="math notranslate nohighlight">\(\sqrt{\Delta x} \| \mathbf{f}' - \mathbf{fx}\|_2\)</span> on every process</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">error</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
 <span class="n">error</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span> <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">funprime</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">i</span><span class="p">))</span>
    <span class="o">/</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">n</span><span class="p">)),</span><span class="mf">2.0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">error</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Node %d ||f&#39; - fx||_2 = %e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">mynode</span><span class="p">,</span><span class="n">error</span><span class="p">);</span>
</pre></div>
</div>
<p>Then we clear the memory and close the parallel environment</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">fx</span><span class="p">);</span>
<span class="n">MPI_Finalize</span><span class="p">();</span>
</pre></div>
</div>
<p>Further modifications</p>
<ul class="simple">
<li><p>In every case the function <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">firstderiv1Dp_vec</span></code> wants to
exchange information between two adjacent processes, i.e., every
process wants to “swap” is halo with its adjacent process. We can
rewrite the whole function by using the <code class="docutils literal notranslate"><span class="pre">MPI_Sendrecv_replace</span></code>
point-to-point communication routine.</p></li>
<li><p>We can rewrite the entire program in an “embarrassing parallel” way,
if every process has access to <span class="math notranslate nohighlight">\(f\)</span>, and are assuming that all the
interval are partitioned the same way, by using the knowledge of our
<code class="docutils literal notranslate"><span class="pre">rank</span></code> we can compute what are the boundary elements at the
previous and following process. Thus, no communication at all!</p></li>
</ul>
<div class="section" id="full-implementation">
<h2>Full implementation<a class="headerlink" href="#full-implementation" title="Permalink to this headline">¶</a></h2>
<p>First we can implement the sequential version of the code. This simply applies the formulas from the previous section.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%file</span> ccode/sequentialderiv.c
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;math.h&gt;</span>

<span class="n">void</span> <span class="n">firstderiv1D</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">);</span>
<span class="n">void</span> <span class="n">firstderiv1D_vec</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">dx</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">);</span>
<span class="n">double</span> <span class="n">fun</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">);</span>
<span class="n">double</span> <span class="n">funprime</span><span class="p">(</span> <span class="n">double</span> <span class="n">x</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
  <span class="n">double</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="o">*</span><span class="n">fx</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">){</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="n">f</span>  <span class="o">=</span> <span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="o">//</span> <span class="n">firstderiv1D</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fx</span><span class="p">);</span>
  <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">firstderiv1D_vec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fx</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;fx[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%1.2f</span><span class="s2"> f&#39;[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%1.2f</span><span class="s2"> |fx - f&#39;| = </span><span class="si">%1.1e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
      <span class="n">i</span><span class="p">,</span><span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="n">funprime</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">),</span><span class="nb">abs</span><span class="p">(</span><span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span>
        <span class="n">funprime</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">i</span><span class="p">))</span><span class="o">/</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)))));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">firstderiv1D</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">double</span> <span class="n">b</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">){</span>
  <span class="n">double</span> <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="o">*</span><span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">fun</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">fun</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">firstderiv1D_vec</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">dx</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">){</span>
  <span class="n">double</span> <span class="n">scale</span><span class="p">;</span>
  <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">double</span> <span class="n">fun</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">){</span>
  <span class="k">return</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">double</span> <span class="n">funprime</span><span class="p">(</span> <span class="n">double</span> <span class="n">x</span><span class="p">){</span>
  <span class="k">return</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Overwriting ccode/sequentialderiv.c
</pre></div>
</div>
</div>
</div>
<p>Code that can then be converted into its parallel version by dos</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%file</span> ccode/parallelderiv.c
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;math.h&gt;</span>
<span class="c1">#include &quot;mpi.h&quot;</span>

<span class="n">void</span> <span class="n">firstderiv1Dp_vec</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">dx</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">,</span> <span class="nb">int</span> <span class="n">mynode</span><span class="p">,</span> <span class="nb">int</span> <span class="n">totalnodes</span><span class="p">);</span>

<span class="n">double</span> <span class="n">fun</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">);</span>
<span class="n">double</span> <span class="n">funprime</span><span class="p">(</span> <span class="n">double</span> <span class="n">x</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
  <span class="n">double</span> <span class="n">globala</span><span class="p">,</span><span class="n">globalb</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="o">*</span><span class="n">fx</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">mynode</span><span class="p">,</span> <span class="n">totalnodes</span><span class="p">;</span>
  <span class="n">MPI_Status</span> <span class="n">status</span><span class="p">;</span>

  <span class="n">MPI_Init</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span> <span class="p">);</span>
  <span class="n">MPI_Comm_rank</span><span class="p">(</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mynode</span> <span class="p">);</span>
  <span class="n">MPI_Comm_size</span><span class="p">(</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">totalnodes</span> <span class="p">);</span>

  <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="n">globala</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">globalb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">globala</span> <span class="o">+</span> <span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">mynode</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">globalb</span> <span class="o">-</span> <span class="n">globala</span><span class="p">)</span><span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="n">double</span><span class="p">)</span> <span class="n">totalnodes</span><span class="p">);</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">globala</span> <span class="o">+</span> <span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">mynode</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">globalb</span> <span class="o">-</span> <span class="n">globala</span><span class="p">)</span><span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="n">double</span><span class="p">)</span> <span class="n">totalnodes</span><span class="p">);</span>

  <span class="n">f</span>  <span class="o">=</span> <span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
  <span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>

  <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">firstderiv1Dp_vec</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">mynode</span><span class="p">,</span> <span class="n">totalnodes</span><span class="p">);</span>

  <span class="n">error</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">error</span> <span class="o">+=</span> <span class="nb">pow</span><span class="p">(</span> <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">funprime</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">i</span><span class="p">))</span><span class="o">/</span><span class="p">((</span><span class="n">double</span><span class="p">)</span> <span class="n">n</span><span class="p">)),</span><span class="mf">2.0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">error</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">%d</span><span class="s2"> ||f&#39; - fx||_2 = </span><span class="si">%e</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">mynode</span><span class="p">,</span><span class="n">error</span><span class="p">);</span>


  <span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">fx</span><span class="p">);</span>
  <span class="n">MPI_Finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">void</span> <span class="n">firstderiv1Dp_vec</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">dx</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span><span class="n">fx</span><span class="p">,</span> <span class="nb">int</span> <span class="n">mynode</span><span class="p">,</span> <span class="nb">int</span> <span class="n">totalnodes</span><span class="p">){</span>
<span class="n">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dx</span><span class="p">);</span>
<span class="n">double</span> <span class="n">mpitemp</span><span class="p">;</span>
<span class="n">MPI_Status</span> <span class="n">status</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
 <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="p">(</span><span class="n">totalnodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)){</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
   <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
   <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
   <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
   <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpitemp</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">mynode</span> <span class="o">==</span> <span class="p">(</span><span class="n">totalnodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)){</span>
  <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
  <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">mpitemp</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
  <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
 <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 <span class="n">fx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">mpitemp</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
 <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
 <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
 <span class="n">mpitemp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
 <span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
 <span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpitemp</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">mynode</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 <span class="n">fx</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpitemp</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">double</span> <span class="n">fun</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">){</span>
  <span class="k">return</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">double</span> <span class="n">funprime</span><span class="p">(</span> <span class="n">double</span> <span class="n">x</span><span class="p">){</span>
  <span class="k">return</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Overwriting ccode/parallelderiv.c
</pre></div>
</div>
</div>
</div>
<p>For which we add again to the Makefile</p>
<div class="highlight-Makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">parallelderiv</span><span class="o">:</span> <span class="n">parallelderiv</span>.<span class="n">c</span>
	<span class="k">$(</span>MPICC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> <span class="nv">$?</span> <span class="k">$(</span>LDLIBS<span class="k">)</span> -o <span class="nv">$@</span>
</pre></div>
</div>
<p>and compile with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">parallelderiv</span></code> and run as</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!(</span><span class="nb">cd</span> ccode <span class="o">&amp;&amp;</span> make parallelderiv<span class="o">)</span>
<span class="o">!</span>mpirun -np <span class="m">4</span> ccode/parallelderiv
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>make[1]: ingresso nella directory &quot;/home/cirdan/Documenti/RTDa-PISA/CorsoCalcoloParallelo2021/introtoparallelcomputing/intrompi/ccode&quot;
mpicc			 -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/cirdan/anaconda3/envs/parallel/include -g			 -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,-rpath,/home/cirdan/anaconda3/envs/parallel/lib -Wl,-rpath-link,/home/cirdan/anaconda3/envs/parallel/lib -L/home/cirdan/anaconda3/envs/parallel/lib parallelderiv.c -lm -ldl -o parallelderiv
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>make[1]: uscita dalla directory &quot;/home/cirdan/Documenti/RTDa-PISA/CorsoCalcoloParallelo2021/introtoparallelcomputing/intrompi/ccode&quot;
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Node 0 ||f&#39; - fx||_2 = 1.384681e-05
Node 1 ||f&#39; - fx||_2 = 1.211868e-05
Node 2 ||f&#39; - fx||_2 = 1.059319e-05
Node 3 ||f&#39; - fx||_2 = 8.880167e-06
</pre></div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="intro.html" title="previous page">Message Passing Interface</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Fabio Durastante<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>